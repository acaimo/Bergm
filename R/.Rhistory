noisy.thin,
prior.mean,
prior.sigma){
# Parameters for ergm.mcmcslave():
y       <- ergm.getnetwork(formula)
model   <- ergm.getmodel(formula, y)
Clist   <- ergm.Cprepare(y, model)
control <- control.simulate.formula(MCMC.burnin   = aux.iters,
MCMC.interval = noisy.thin)
control$MCMC.samplesize <- noisy.nsim
MHproposal <- MHproposal.ergm(object      = model,
constraints = ~.,
arguments   = control$MCMC.prop.args,
nw          = y,
weights     = control$MCMC.prop.weights,
class       = "c",
reference   = ~Bernoulli,
response    = NULL)
sy        <- summary(formula)
theta     <- array(0, c(dim=iters, length(sy)) )
theta[1,] <- init
pb <- txtProgressBar(min = 0, max = iters, style=3)
for(i in 2:iters){
z <- ergm.mcmcslave(Clist      = Clist,
MHproposal = MHproposal,
eta0       = theta[i-1,],
control    = control,
verbose    = FALSE)
estgrad   <- -apply(z$s, 2, mean) - solve(prior.sigma, (theta[i-1,] - prior.mean))
theta[i,] <- theta[i-1,]  + ((a/i)*(alpha + estgrad))
setTxtProgressBar(pb, i)
}# End for
out <- list(Theta = theta)
return(out)
}# End function
#==========================
# Model dimensions:
mdims <- length(mspecs(ergm.formula))
# Default prior specification:
if (is.null(prior.mean)) prior.mean <- rep(0, mdims)
if (is.null(prior.sigma)) prior.sigma <- diag(100, mdims)
# Get data in aggregated format:
mplesetup                 <- ergmMPLE(ergm.formula)
data.glm.initial          <- cbind(mplesetup$response,
mplesetup$weights,
mplesetup$predictor)
colnames(data.glm.initial) <- c("responses",
"weights",
colnames(mplesetup$predictor))
# Variance-covariance matrix from MPLE:
Vcov.MPLE <- vcov(glm(mplesetup$response ~ . - 1,
data    = data.frame(mplesetup$predictor),
weights = mplesetup$weights,
family  = "binomial"))
# Tuning the variance-covariance matrix of the proposal distribution:
tune.mat.PL      <- diag(rep(tunePL, mdims))
B0               <- solve(prior.sigma)
PL.prop.sigma.mat<- tune.mat.PL %*% solve((B0 + solve(Vcov.MPLE))) %*% tune.mat.PL
# Obtain the MPLE for the model of interest:
capture.output(mple <- ergm(ergm.formula, estimate = "MPLE") )
message("---MCMC start---")
#==========================
# Start the clock:
clock.start <- Sys.time()
#==========================
capture.output(unadj.sample <- MCMCmetrop1R(log_pseudo_post_short,
theta.init  = mple$coef,
y           = mplesetup$response,
X           = mplesetup$predictor,
weights     = mplesetup$weights,
optimPL     = F,
prior.mean  = prior.mean,
prior.sigma = prior.sigma,
V           = PL.prop.sigma.mat,
thin        = thin,
mcmc        = mcmc,
burnin      = burnin,
logfun      = TRUE))
# End pseudo likelihood estimation
#==========================
# Use the MPLE to initialise the Robbins-Monro algorithm:
capture.output(rob.mon.init <- ergm(ergm.formula, estimate = "MPLE"))
sy <- summary(ergm.formula)
message("---MAP estimation---")
#==========================
# Estimate the MAP of the true posterior:
theta.star <- robinsmon.ergm(ergm.formula,
iters       = iters,
a           = a,
alpha       = alpha,
init        = rob.mon.init$coef,
aux.iters   = aux.iters,
noisy.nsim  = noisy.nsim,
noisy.thin  = noisy.thin,
prior.mean  = prior.mean,
prior.sigma = prior.sigma)
theta.PLstar <- optim(par         = summary(unadj.sample)$statistics[,1],
fn          = log_pseudo_post_short,
gr          = score.logpp,
lower       = rob.mon.init$coef-3,
upper       = rob.mon.init$coef+3,
y           = mplesetup$response,
X           = mplesetup$predictor,
weights     = mplesetup$weights,
optimPL     = T,
prior.mean  = prior.mean,
prior.sigma = prior.sigma,
hessian     = TRUE,
method      = "L-BFGS-B")
message("---Curvature Adjustment---")
#==========================
# Simulate graphs from \theta^{*}::
sim.samples<- simulate(ergm.formula,
coef     = theta.star$Theta[iters,],
statsonly= T,
nsim     = noisy.nsim,
control  = control.simulate(MCMC.burnin   = aux.iters,
MCMC.interval = noisy.thin) )
#==========================
# Hessian of true log-posterior:
Hessian.post.truelike<- -cov(sim.samples) - solve(prior.sigma)
#==========================
chol.true.posterior<- chol(-Hessian.post.truelike)
chol.PL.posterior  <- chol(-theta.PLstar$hessian)
#==========================
# Calculate transformation matrix W:
W <- solve(chol.PL.posterior)%*%chol.true.posterior
V <- solve(W)
#==========================
# Correct the sample:
corrected.sample <- t(apply(data.frame(unadj.sample), 1,
function(x) {
c( V%*%( unlist(x) - theta.PLstar$par ) +
theta.star$Theta[iters,] )
}# End function
)
)
#==========================
# Close the clock:
clock.end <- Sys.time()
runtime   <- difftime(clock.end, clock.start)
#==========================
# Summarize the MCMC sample:
corrected.sample.mcmc<- mcmc(corrected.sample)
ess                  <- round(effectiveSize(corrected.sample.mcmc),0)
names(ess)           <- mspecs(ergm.formula)
AR        <- round(1-rejectionRate(corrected.sample.mcmc)[1], 2)
names(AR) <- NULL
#==========================
out <- list(Theta_star      = theta.star$Theta[iters,],
Theta_PL        = theta.PLstar$par,
W               = W,
Theta           = corrected.sample.mcmc,
Time            = runtime,
formula         = ergm.formula,
AR              = AR,
ESS             = ess,
dim             = length(names(ess)),
specs           = names(ess)
)
class(out) <-"calibrate.bergm"
return(out)
}# End function
posterior <- bergm(flomarriage ~ edges + kstar(2),
burn.in = 50,
aux.iters = 500,
main.iters = 5000,
gamma = 1)
bergm.output(posterior)
bgof(posterior,
aux.iters = 500,
sample.size = 50,
n.deg = 10,
n.dist = 9,
n.esp = 6)
posterior <- calibrate.bergm(flo.formula,
iters        = 500,
a            = 0.001,
alpha        = 0,
aux.iters    = 3000,
noisy.nsim   = 400,
noisy.thin   = 50,
thin         = 1,
mcmc         = 4e04,
burnin       = 1e04,
tunePL       = 2
)
bergm.output(posterior)
bgof(posterior,
aux.iters = 500,
sample.size = 50,
n.deg = 10,
n.dist = 9,
n.esp = 6)
#' Bayesian goodness-of-fit diagnostics for ERGMs
#'
#' Function to calculate summaries for degree,
#' minimum geodesic distances,
#' and edge-wise shared partner distributions
#' to diagnose the Bayesian goodness-of-fit of
#' exponential random graph models.
#'
#' @param x; an \code{R} object of class \code{bergm}, \code{pseudo.bergm} or \code{calibrate.bergm}.
#'
#' @param directed logiocal; logical; TRUE if the observed graph is directed.
#'
#' @param sample.size count; number of networks
#' to be simulated and compared to the observed network.
#'
#' @param aux.iters count; number of iterations used for network simulation.
#'
#' @param n.deg count; used to plot only the first
#' \code{n.deg}-1 degree distributions.
#' By default no restrictions on the number of degree
#' distributions is applied.
#'
#' @param n.dist count; used to plot only the first
#' \code{n.dist}-1 geodesic distances distributions.
#' By default no restrictions on the number of geodesic
#' distances distributions is applied.
#'
#' @param n.esp count; used to plot only the first
#' \code{n.esp}-1 edge-wise shared partner distributions.
#' By default no restrictions on the number of
#' edge-wise shared partner distributions is applied.
#'
#' @param n.ideg count; used to plot only the first
#' \code{n.ideg}-1 in-degree distributions.
#' By default no restrictions on the number of
#' in-degree distributions is applied.
#'
#' @param n.odeg count; used to plot only the first
#' \code{n.odeg}-1 out-degree distributions.
#' By default no restrictions on the number of
#' out-degree distributions is applied.
#'
#' @param ... additional arguments,
#' to be passed to lower-level functions.
#'
#' @references
#' Caimo, A. and Friel, N. (2011), "Bayesian Inference for Exponential Random Graph Models,"
#' Social Networks, 33(1), 41 – 55. \url{http://arxiv.org/abs/1007.5192}
#'
#' Caimo, A. and Friel, N. (2014), "Bergm: Bayesian Exponential Random Graphs in R,"
#' Journal of Statistical Software, 61(2), 1 – 25. \url{jstatsoft.org/v61/i02}
#'
#' @import network
#' @import ergm
#'
#' @export
#'
#' @seealso \code{\link{bergm}}, \code{\link{calibrate.bergm}}.
bgof <- function(x,
directed=FALSE,
sample.size=100,
aux.iters=10000,
n.deg=NULL,
n.dist=NULL,
n.esp=NULL,
n.ideg=NULL,
n.odeg=NULL,
...){
if (class(x) == "bergm") {
if (x$nchains > 1) x$Theta <- apply(x$Theta, 2, cbind)
F <- as.matrix(x$Theta[sample(dim(x$Theta)[1], sample.size), ])
# From pseudo.bergm() or calibrate.bergm()
} else if (class(x) == "calibrate.bergm"){
F <- x$Theta
}
if(directed==FALSE){ # undirected
for(i in 1:sample.size){
a <- gof.formula(x$formula,
coef=F[i,],
verbose=FALSE,
control=control.gof.formula(nsim=1, MCMC.burnin=aux.iters))
if(i==1) A<-as.vector(a$pobs.deg)
A<-cbind(A,as.vector(a$psim.deg))
if(i==1) B<-as.vector(a$pobs.dist)
B<-cbind(B,as.vector(a$psim.dist))
if(i==1) C<-as.vector(a$pobs.espart)
C<-cbind(C,as.vector(a$psim.espart))
}
if(is.null(n.deg)) n.deg <- dim(A)[1]
if(is.null(n.dist)) n.dist <- dim(B)[1]-1
if(is.null(n.esp)) n.esp <- dim(C)[1]
a5 <- apply(A[1:n.deg,-1],
1,quantile,probs=0.05)
b5 <- apply(B[-(n.dist:(dim(B)[1]-1)),-1],
1,quantile,probs=0.05)
c5 <- apply(C[1:n.esp,-1],
1,quantile,probs=0.05)
a95 <- apply(A[1:n.deg,-1],
1,quantile,probs=0.95)
b95 <- apply(B[-(n.dist:(dim(B)[1]-1)),-1],
1,quantile,probs=0.95)
c95 <- apply(C[1:n.esp,-1],
1,quantile,probs=0.95)
par(mfrow=c(1,3),oma=c(0,0,3,0),mar=c(4,3,1.5,1))
boxplot(as.data.frame(t(A[1:n.deg,-1])),
xaxt="n",
xlab="degree",
ylab="proportion of nodes")
axis(1,seq(1,n.deg),seq(0,n.deg-1))
lines(A[1:n.deg,1],lwd=2,col=2)
lines(a5,col="darkgray")
lines(a95,col="darkgray")
title("Bayesian goodness-of-fit diagnostics",outer=TRUE)
boxplot(as.data.frame(t(B[-(n.dist:(dim(B)[1]-1)),-1])),
xaxt="n",
xlab="minimum geodesic distance",
ylab="proportion of dyads")
axis(1,seq(1,n.dist),labels=c(seq(1,(n.dist-1)),"NR"))
lines(B[-(n.dist:(dim(B)[1]-1)),1],lwd=2,col=2)
lines(b5,col="darkgray")
lines(b95,col="darkgray")
boxplot(as.data.frame(t(C[1:n.esp,-1])),
xaxt="n",
xlab="edge-wise shared partners",
ylab="proportion of edges")
axis(1,seq(1,n.esp),seq(0,n.esp-1))
lines(C[1:n.esp,1],lwd=2,col=2)
lines(c5,col="darkgray")
lines(c95,col="darkgray")
out = list(sim.degree=A[,-1],
sim.dist=B[,-1],
sim.esp=C[,-1],
obs.degree=A[,1],
obs.dist=B[,1],
obs.esp=C[,1],
fun=F)
}else{ # directed
for(i in 1:sample.size){
a <- gof.formula(x$formula,
coef=F[i,],
verbose=FALSE,
GOF=~idegree+odegree+espartners+distance,
control=control.gof.formula(nsim=1, MCMC.burnin=aux.iters))
if(i==1) A<-as.vector(a$pobs.ideg)
A<-cbind(A,as.vector(a$psim.ideg))
if(i==1) AA<-as.vector(a$pobs.odeg)
AA<-cbind(AA,as.vector(a$psim.odeg))
if(i==1) B<-as.vector(a$pobs.dist)
B<-cbind(B,as.vector(a$psim.dist))
if(i==1) C<-as.vector(a$pobs.espart)
C<-cbind(C,as.vector(a$psim.espart))
}
if(is.null(n.ideg)) n.ideg <- dim(A)[1]
if(is.null(n.odeg)) n.odeg <- dim(AA)[1]
if(is.null(n.dist)) n.dist <- dim(B)[1]-1
if(is.null(n.esp)) n.esp <- dim(C)[1]
a5 <- apply(A[1:n.ideg,-1],1,quantile,probs=0.05)
aa5 <- apply(AA[1:n.odeg,-1],1,quantile,probs=0.05)
b5 <- apply(B[-(n.dist:(dim(B)[1]-1)),-1],1,quantile,probs=0.05)
c5 <- apply(C[1:n.esp,-1],1,quantile,probs=0.05)
a95 <- apply(A[1:n.ideg,-1],1,quantile,probs=0.95)
aa95 <- apply(AA[1:n.odeg,-1],1,quantile,probs=0.95)
b95 <- apply(B[-(n.dist:(dim(B)[1]-1)),-1],1,quantile,probs=0.95)
c95 <- apply(C[1:n.esp,-1],1,quantile,probs=0.95)
par(mfrow=c(2,2),oma=c(0,0,3,0),mar=c(4,3,1.5,1))
boxplot(as.data.frame(t(A[1:n.ideg,-1])),
xaxt="n",
xlab="in degree",
ylab="proportion of nodes")
axis(1,seq(1,n.ideg),seq(0,n.ideg-1))
lines(A[1:n.ideg,1],lwd=2,col=2)
lines(a5,col="darkgray")
lines(a95,col="darkgray")
title("Bayesian goodness-of-fit diagnostics",outer=TRUE)
boxplot(as.data.frame(t(AA[1:n.odeg,-1])),
xaxt="n",
xlab="out degree",
ylab="proportion of nodes")
axis(1,seq(1,n.odeg),seq(0,n.odeg-1))
lines(AA[1:n.odeg,1],lwd=2,col=2)
lines(aa5,col="darkgray")
lines(aa95,col="darkgray")
boxplot(as.data.frame(t(B[-(n.dist:(dim(B)[1]-1)),-1])),
xaxt="n",
xlab="minimum geodesic distance",
ylab="proportion of dyads")
axis(1,seq(1,n.dist),labels=c(seq(1,(n.dist-1)),"NR"))
lines(B[-(n.dist:(dim(B)[1]-1)),1],lwd=2,col=2)
lines(b5,col="darkgray")
lines(b95,col="darkgray")
boxplot(as.data.frame(t(C[1:n.esp,-1])),
xaxt="n",
xlab="edge-wise shared partners",
ylab="proportion of edges")
axis(1,seq(1,n.esp),seq(0,n.esp-1))
lines(C[1:n.esp,1],lwd=2,col=2)
lines(c5,col="darkgray")
lines(c95,col="darkgray")
out = list(sim.idegree=A[,-1],
sim.odegree=AA[,-1],
sim.dist=B[,-1],
sim.esp=C[,-1],
obs.degree=A[,1],
obs.dist=B[,1],
obs.esp=C[,1],
fun=F)
}
}
#' Summarising posterior BERGM output
#'
#' This function returns the posterior parameter density estimate
#' and creates simple diagnostic plots for the MCMC produced from a fit.
#'
#' @param x an \code{R} object of class \code{bergm}, \code{pseudo.bergm},
#' or \code{calibrate.bergm}
#'
#' @param ... additional arguments, to be passed to lower-level functions.
#'
#' @import coda
#' @import ergm
#'
bergm.output <- function (x, ...) {
# From bergm()
if (class(x) == "bergm") {
if (x$nchains > 1) {
x$AR <- mean(x$AR)
FF <- mcmc(apply(x$Theta, 2, cbind))
} else {
FF <- mcmc(x$Theta)
rates <- matrix(x$AR, 1, x$dim)
}
# From pseudo.bergm() or calibrate.bergm()
} else if (class(x) == "calibrate.bergm"){
FF <- mcmc(x$Theta)
}
cat("\n", "Posterior Density Estimate for Model: y ~", paste(x$formula[3]), "\n", "\n")
#overall           <- cbind(apply(FF, 2, mean), apply(FF, 2, sd))
#colnames(overall) <- c("Post. mean:", "Post. sd:")
#rownames(overall) <- paste("theta", seq(1, x$dim), " (", x$specs[seq(1, x$dim)], ")", sep = "")
#all <- as.table(overall)
table1 <- summary(FF)$statistics
table2 <- summary(FF)$quantiles
rownames(table1) <- paste("theta", seq(1, x$dim),
" (", x$specs[seq(1, x$dim)], ")",
sep = "")
rownames(table2) <- paste("theta", seq(1, x$dim),
" (", x$specs[seq(1, x$dim)], ")",
sep = "")
print(table1); cat("\n"); print(table2)
cat("\n", "Acceptance rate:", x$AR, "\n", "\n", "\n")
dev.new()
seqq <- 4
par(mfrow = c(min(4, x$dim), 3),
oma   = c(0, 0, 3, 0),
mar   = c(4, 3, 1.5, 1))
for (i in 1:x$dim) {
if (i %in% c(5, 9, 13)) {
dev.new()
par(mfrow = c(min(4, x$dim - (i - 1)), 3),
oma = c(0, 0, 3, 0),
mar = c(4, 3, 1.5, 1))
}
plot(density(FF[, i]),
main = "",
axes = FALSE,
xlab = bquote(paste(theta[.(i)], " (", .(x$specs[i]), ")")),
ylab = "", lwd = 2)
axis(1)
axis(2)
traceplot(FF[, i], type = "l", xlab = "Iterations", ylab = "")
autocorr.plot(FF[, i], auto.layout = FALSE)
if (x$dim > 4) seqq <- seq(4, x$dim, 4)
if (i %in% union(x$dim, seqq)) title(paste("MCMC output for Model: y ~", x$formula[3]), outer = TRUE)
}
out <- list(statistics = summary(FF)$statistics,
quantiles = summary(FF)$quantiles,
theta = FF)
}
posterior <- calibrate.bergm(flo.formula,
iters        = 500,
a            = 0.001,
alpha        = 0,
aux.iters    = 3000,
noisy.nsim   = 400,
noisy.thin   = 50,
thin         = 1,
mcmc         = 4e04,
burnin       = 1e04,
tunePL       = 2
)
bergm.output(posterior)
bgof(posterior,
aux.iters = 500,
sample.size = 50,
n.deg = 10,
n.dist = 9,
n.esp = 6)
posterior <- bergm(flomarriage ~ edges + kstar(2),
burn.in = 50,
aux.iters = 500,
main.iters = 5000,
gamma = 1)
bergm.output(posterior)
bgof(posterior,
aux.iters = 500,
sample.size = 50,
n.deg = 10,
n.dist = 9,
n.esp = 6)
4e03
1e04
capture.output(rob.mon.init <- ergm(ergm.formula,
estimate = "MLE"),
control = control.ergm(MCMC.samplesize = 1000))
library(roxygen2)
roxygenise(package.dir = '/Users/usilugano/Dropbox/Research/Bergm_package/Bergm')
library(roxygen2)
roxygenise(package.dir = '/Users/usilugano/Dropbox/Research/Bergm_package/Bergm')
